# Utilities - Copilot Instructions

## Purpose
This folder contains **shared utility code** that doesn't fit into ECS components, systems, or aspects. This includes math helpers, blob asset builders, constants, and pure functions.

## Rules

### 1. Utilities Must Be Stateless & Pure
```csharp
// ? Good: Pure static utility functions
public static class MathUtilities {
    public static float3 ProjectOnPlane(float3 vector, float3 planeNormal) {
        return vector - math.dot(vector, planeNormal) * planeNormal;
    }
    
    public static bool IsPointInBounds(float3 point, Bounds bounds) {
        return point.x >= bounds.Min.x && point.x <= bounds.Max.x &&
               point.y >= bounds.Min.y && point.y <= bounds.Max.y &&
               point.z >= bounds.Min.z && point.z <= bounds.Max.z;
    }
}

// ? Bad: Stateful utility class
public class MathUtilities {
    private static float cachedValue; // ? No static state
    
    public static void UpdateCache(float value) { // ? Side effects
        cachedValue = value;
    }
}
```

### 2. Use Burst-Compatible Types
```csharp
// ? Good: Burst-compatible math utilities
public static class GridUtilities {
    [BurstCompile]
    public static int2 WorldToGrid(float3 worldPos, float cellSize) {
        return new int2(
            (int)math.floor(worldPos.x / cellSize),
            (int)math.floor(worldPos.z / cellSize)
        );
    }
    
    [BurstCompile]
    public static float3 GridToWorld(int2 gridPos, float cellSize) {
        return new float3(
            gridPos.x * cellSize + cellSize * 0.5f,
            0,
            gridPos.y * cellSize + cellSize * 0.5f
        );
    }
}

// ? Bad: Using managed types
public static class GridUtilities {
    public static Vector2Int WorldToGrid(Vector3 worldPos) { // ? Managed types
        return new Vector2Int(
            Mathf.FloorToInt(worldPos.x), // ? UnityEngine.Mathf not Burst-compatible
            Mathf.FloorToInt(worldPos.z)
        );
    }
}
```

### 3. Constants in Static Classes
```csharp
// ? Good: Constants grouped by domain
public static class GameConstants {
    public const float DefaultSpeed = 10.0f;
    public const float MaxSpeed = 100.0f;
    public const int MaxEntities = 100000;
}

public static class GridConstants {
    public const float CellSize = 1.0f;
    public const int ChunkSize = 16;
    public const int MaxChunks = 256;
}

// ? Bad: Magic numbers scattered in code
public void Update() {
    if (speed > 100.0f) // ? Magic number
        speed = 100.0f;
}
```

### 4. Blob Asset Builders
```csharp
// ? Good: Blob asset builder utility
public static class VehicleDefinitionBuilder {
    /// <summary>
    /// Creates a blob asset for vehicle definition data.
    /// </summary>
    public static BlobAssetReference<VehicleDefinition> Create(
        VehicleConfig config,
        Mesh mesh) {
        
        using var builder = new BlobBuilder(Allocator.Temp);
        ref var root = ref builder.ConstructRoot<VehicleDefinition>();
        
        // Build blob arrays
        var vertices = builder.Allocate(ref root.Vertices, mesh.vertexCount);
        var indices = builder.Allocate(ref root.Indices, mesh.triangles.Length);
        
        // Copy data
        for (int i = 0; i < mesh.vertexCount; i++) {
            vertices[i] = mesh.vertices[i];
        }
        for (int i = 0; i < mesh.triangles.Length; i++) {
            indices[i] = mesh.triangles[i];
        }
        
        // Set properties
        root.MaxSpeed = config.maxSpeed;
        root.Acceleration = config.acceleration;
        
        return builder.CreateBlobAssetReference<VehicleDefinition>(Allocator.Persistent);
    }
}

// Define blob structure in Components folder
public struct VehicleDefinition {
    public BlobArray<float3> Vertices;
    public BlobArray<int> Indices;
    public float MaxSpeed;
    public float Acceleration;
}
```

### 5. Extension Methods for Unity.Mathematics
```csharp
// ? Good: Extensions for common operations
public static class MathExtensions {
    /// <summary>
    /// Returns the squared length of a float3 vector (faster than length).
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float LengthSq(this float3 v) {
        return math.dot(v, v);
    }
    
    /// <summary>
    /// Checks if all components are finite (not NaN or Infinity).
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsFinite(this float3 v) {
        return math.isfinite(v.x) && math.isfinite(v.y) && math.isfinite(v.z);
    }
    
    /// <summary>
    /// Converts int2 to float3 with zero Y component.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static float3 ToFloat3XZ(this int2 v) {
        return new float3(v.x, 0, v.y);
    }
}
```

### 6. Naming Conventions
- **Static utility classes**: Suffix with `Utilities` or `Utils` (e.g., `GridUtilities`, `PathfindingUtils`)
- **Constants classes**: Suffix with `Constants` (e.g., `GameConstants`, `PhysicsConstants`)
- **Builders**: Suffix with `Builder` (e.g., `TerrainBuilder`, `MeshBuilder`)
- **Extensions**: Suffix with `Extensions` (e.g., `MathExtensions`, `EntityExtensions`)

### 7. Documentation
Every public utility must have XML documentation explaining:
- **Purpose**: What does this utility do?
- **Parameters**: What do the parameters represent? (units, constraints)
- **Returns**: What does it return?
- **Example**: How to use it

```csharp
/// <summary>
/// Converts a world-space position to grid coordinates.
/// </summary>
/// <param name="worldPos">World-space position in meters</param>
/// <param name="cellSize">Size of each grid cell in meters</param>
/// <returns>Grid coordinates (x, y)</returns>
/// <example>
/// <code>
/// var gridPos = GridUtilities.WorldToGrid(new float3(5.5f, 0, 3.2f), 1.0f);
/// // Returns int2(5, 3)
/// </code>
/// </example>
[BurstCompile]
public static int2 WorldToGrid(float3 worldPos, float cellSize) {
    return new int2(
        (int)math.floor(worldPos.x / cellSize),
        (int)math.floor(worldPos.z / cellSize)
    );
}
```

## Common Utility Categories

### Math Utilities
```csharp
public static class MathUtilities {
    // Vector operations
    public static float3 ProjectOnPlane(float3 vector, float3 normal);
    public static float SignedAngle(float3 from, float3 to, float3 axis);
    
    // Interpolation
    public static float SmoothStep(float a, float b, float t);
    public static float3 CatmullRom(float3 p0, float3 p1, float3 p2, float3 p3, float t);
    
    // Bounds & collision
    public static bool OverlapAABB(Bounds a, Bounds b);
    public static float DistancePointToLine(float3 point, float3 lineStart, float3 lineEnd);
}
```

### Grid Utilities
```csharp
public static class GridUtilities {
    // Coordinate conversion
    public static int2 WorldToGrid(float3 worldPos, float cellSize);
    public static float3 GridToWorld(int2 gridPos, float cellSize);
    
    // Grid queries
    public static int GridIndex(int2 gridPos, int gridWidth);
    public static int2 IndexToGrid(int index, int gridWidth);
    
    // Neighbors
    public static NativeArray<int2> GetNeighbors4(int2 gridPos, Allocator allocator);
    public static NativeArray<int2> GetNeighbors8(int2 gridPos, Allocator allocator);
}
```

### Pathfinding Utilities
```csharp
public static class PathfindingUtilities {
    // Heuristics
    [BurstCompile]
    public static float ManhattanDistance(int2 a, int2 b) {
        return math.abs(a.x - b.x) + math.abs(a.y - b.y);
    }
    
    [BurstCompile]
    public static float EuclideanDistance(int2 a, int2 b) {
        var dx = a.x - b.x;
        var dy = a.y - b.y;
        return math.sqrt(dx * dx + dy * dy);
    }
    
    // Path smoothing
    public static void SmoothPath(ref NativeList<float3> path, int iterations);
}
```

### Random Utilities
```csharp
public static class RandomUtilities {
    /// <summary>
    /// Returns a random point inside a circle.
    /// </summary>
    [BurstCompile]
    public static float3 RandomPointInCircle(ref Random random, float3 center, float radius) {
        var angle = random.NextFloat(0, math.PI * 2);
        var distance = math.sqrt(random.NextFloat()) * radius;
        return center + new float3(
            math.cos(angle) * distance,
            0,
            math.sin(angle) * distance
        );
    }
    
    /// <summary>
    /// Returns a random point inside an axis-aligned bounding box.
    /// </summary>
    [BurstCompile]
    public static float3 RandomPointInBounds(ref Random random, Bounds bounds) {
        return new float3(
            random.NextFloat(bounds.Min.x, bounds.Max.x),
            random.NextFloat(bounds.Min.y, bounds.Max.y),
            random.NextFloat(bounds.Min.z, bounds.Max.z)
        );
    }
}
```

### Color Utilities
```csharp
public static class ColorUtilities {
    /// <summary>
    /// Converts HSV to RGB color.
    /// </summary>
    [BurstCompile]
    public static float4 HSVToRGB(float h, float s, float v, float a = 1.0f) {
        var c = v * s;
        var x = c * (1 - math.abs((h / 60.0f) % 2 - 1));
        var m = v - c;
        
        float3 rgb = float3.zero;
        if (h < 60) rgb = new float3(c, x, 0);
        else if (h < 120) rgb = new float3(x, c, 0);
        else if (h < 180) rgb = new float3(0, c, x);
        else if (h < 240) rgb = new float3(0, x, c);
        else if (h < 300) rgb = new float3(x, 0, c);
        else rgb = new float3(c, 0, x);
        
        return new float4(rgb + m, a);
    }
}
```

## Testing Utilities

### Test Data Builders
```csharp
#if UNITY_EDITOR || UNITY_INCLUDE_TESTS
public static class TestEntityBuilder {
    /// <summary>
    /// Creates a test entity with position and velocity.
    /// </summary>
    public static Entity CreateMovingEntity(
        EntityManager manager,
        float3 position,
        float3 velocity) {
        
        var entity = manager.CreateEntity();
        manager.AddComponentData(entity, new LocalTransform {
            Position = position,
            Rotation = quaternion.identity,
            Scale = 1.0f
        });
        manager.AddComponentData(entity, new Velocity { Value = velocity });
        return entity;
    }
    
    /// <summary>
    /// Creates a test grid with specified dimensions.
    /// </summary>
    public static Entity CreateTestGrid(
        EntityManager manager,
        int width,
        int height) {
        
        var gridEntity = manager.CreateEntity();
        var tiles = manager.AddBuffer<GridTile>(gridEntity);
        
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                tiles.Add(new GridTile {
                    Position = new int2(x, y),
                    Type = TileType.Grass
                });
            }
        }
        
        return gridEntity;
    }
}
#endif
```

## Performance Best Practices

### 1. Use MethodImplOptions.AggressiveInlining
```csharp
// ? Good: Inline simple, frequently-called methods
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public static float DistanceSquared(float3 a, float3 b) {
    var diff = a - b;
    return math.dot(diff, diff);
}

// ? Bad: Complex method marked for inlining
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public static NativeArray<float3> ComputeComplexPath(...) { // ? Too complex to inline
    // 100+ lines of code...
}
```

### 2. Prefer math Over Mathf
```csharp
// ? Good: Unity.Mathematics (Burst-compatible)
var result = math.sqrt(value);
var angle = math.atan2(y, x);
var clamped = math.clamp(value, min, max);

// ? Bad: UnityEngine.Mathf (not Burst-compatible)
var result = Mathf.Sqrt(value);
var angle = Mathf.Atan2(y, x);
var clamped = Mathf.Clamp(value, min, max);
```

### 3. Cache Expensive Calculations
```csharp
public static class CachedConstants {
    public static readonly float Sqrt2 = math.sqrt(2.0f);
    public static readonly float InvSqrt2 = 1.0f / math.sqrt(2.0f);
    public static readonly float DegToRad = math.PI / 180.0f;
    public static readonly float RadToDeg = 180.0f / math.PI;
}
```

## Anti-Patterns

### ? Singleton Utilities
```csharp
// ? Bad: Singleton utility (use static class instead)
public class GameUtilities : MonoBehaviour {
    public static GameUtilities Instance { get; private set; }
    
    void Awake() {
        Instance = this;
    }
}

// ? Good: Static utility class
public static class GameUtilities {
    public static float CalculateSomething(float input) {
        return input * 2.0f;
    }
}
```

### ? Utilities with State
```csharp
// ? Bad: Stateful utility
public static class Cache {
    private static Dictionary<int, float> values = new(); // ? Mutable state
    
    public static void Store(int key, float value) {
        values[key] = value;
    }
}

// ? Good: Stateless, caller manages storage
public static class MathUtilities {
    public static float Compute(float input) {
        return input * 2.0f;
    }
}
```

### ? Over-Abstraction
```csharp
// ? Bad: Unnecessary abstraction
public static class FloatWrapper {
    public static float Add(float a, float b) {
        return a + b; // ? Just use a + b directly
    }
}

// ? Good: Meaningful abstraction
public static class GridUtilities {
    public static int2 WorldToGrid(float3 worldPos, float cellSize) {
        return new int2(
            (int)math.floor(worldPos.x / cellSize),
            (int)math.floor(worldPos.z / cellSize)
        );
    }
}
```

## File Organization
- Group related utilities in subdirectories:
  - `Utilities/Math/`
  - `Utilities/Grid/`
  - `Utilities/Pathfinding/`
  - `Utilities/Builders/`
- One utility class per file
- File name matches class name: `GridUtilities.cs`, `MathExtensions.cs`
