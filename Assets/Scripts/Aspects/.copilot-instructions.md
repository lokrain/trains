# Aspects - Copilot Instructions

## Purpose
This folder contains **ECS aspects** that provide a convenient way to group related components and define reusable behaviors. Aspects are readonly structs that reference components.

## Rules

### 1. Aspects Are Readonly & Reference Components
```csharp
// ? Good: Readonly aspect with component references
public readonly partial struct TransformAspect : IAspect {
    readonly RefRW<LocalTransform> transform;
    readonly RefRO<Velocity> velocity;
    
    public float3 Position {
        get => transform.ValueRO.Position;
        set => transform.ValueRW.Position = value;
    }
    
    public void Move(float deltaTime) {
        transform.ValueRW.Position += velocity.ValueRO.Value * deltaTime;
    }
}

// ? Bad: Mutable state in aspect
public partial struct TransformAspect : IAspect {
    private float cachedSpeed; // ? No mutable fields
    RefRW<LocalTransform> transform;
}
```

### 2. Use Aspects for Cohesive Component Groups
```csharp
// ? Good: Logically related components
public readonly partial struct VehicleAspect : IAspect {
    readonly RefRW<LocalTransform> transform;
    readonly RefRO<Velocity> velocity;
    readonly RefRO<Speed> speed;
    readonly RefRO<VehicleConfig> config;
    
    public void UpdateMovement(float deltaTime) {
        var direction = math.normalize(velocity.ValueRO.Value);
        var distance = speed.ValueRO.Value * deltaTime;
        transform.ValueRW.Position += direction * distance;
    }
}

// ? Bad: Unrelated components grouped arbitrarily
public readonly partial struct MiscAspect : IAspect {
    readonly RefRO<Health> health;
    readonly RefRO<RenderMesh> mesh;
    readonly RefRO<AudioSource> audio; // ? No logical cohesion
}
```

### 3. Encapsulate Complex Logic in Aspects
```csharp
// ? Good: Aspect encapsulates train-specific behavior
public readonly partial struct TrainAspect : IAspect {
    readonly RefRW<LocalTransform> transform;
    readonly RefRO<TrackPosition> trackPosition;
    readonly RefRO<Speed> speed;
    readonly RefRO<TrackSegmentRef> currentSegment;
    
    /// <summary>
    /// Moves the train along its current track segment.
    /// </summary>
    /// <param name="deltaTime">Time step in seconds</param>
    /// <param name="trackLookup">Lookup for track segment data</param>
    public void MoveAlongTrack(float deltaTime, 
                               ComponentLookup<TrackSegmentData> trackLookup) {
        if (!trackLookup.HasComponent(currentSegment.ValueRO.Entity))
            return;
            
        var segment = trackLookup[currentSegment.ValueRO.Entity];
        var distance = speed.ValueRO.Value * deltaTime;
        
        // Complex track-following logic encapsulated here
        var newPosition = CalculatePositionOnTrack(
            trackPosition.ValueRO.DistanceAlongTrack + distance,
            segment
        );
        
        transform.ValueRW.Position = newPosition;
    }
    
    private float3 CalculatePositionOnTrack(float distance, TrackSegmentData segment) {
        // Implementation...
        return float3.zero;
    }
}
```

### 4. Use Optional Components with HasComponent
```csharp
// ? Good: Optional component handling
public readonly partial struct EntityAspect : IAspect {
    readonly RefRW<LocalTransform> transform;
    readonly RefRO<Velocity> velocity;
    
    [Optional] readonly RefRO<Acceleration> acceleration;
    [Optional] readonly RefRW<DebugData> debugData;
    
    public void ApplyPhysics(float deltaTime) {
        var vel = velocity.ValueRO.Value;
        
        // Optional acceleration
        if (acceleration.IsValid) {
            vel += acceleration.ValueRO.Value * deltaTime;
        }
        
        transform.ValueRW.Position += vel * deltaTime;
        
        // Optional debug logging
        if (debugData.IsValid) {
            debugData.ValueRW.LastPosition = transform.ValueRO.Position;
        }
    }
}
```

### 5. Naming Conventions
- **Pattern**: `<Noun>Aspect`
- **Examples**: `TransformAspect`, `VehicleAspect`, `BuildingAspect`
- **Avoid**: Generic names like `EntityAspect`, `DataAspect`

### 6. Documentation
Every aspect must have XML documentation explaining:
- **Purpose**: What functionality does this aspect provide?
- **Required Components**: What components must an entity have?
- **Optional Components**: What components are optional?
- **Usage**: Example of how to use the aspect in a system

```csharp
/// <summary>
/// Provides movement functionality for vehicles traveling along tracks.
/// </summary>
/// <remarks>
/// Required components: LocalTransform, TrackPosition, Speed, TrackSegmentRef
/// Optional components: DebugVisualization
/// 
/// Example usage:
/// <code>
/// foreach (var train in SystemAPI.Query&lt;TrainAspect&gt;()) {
///     train.MoveAlongTrack(deltaTime, trackLookup);
/// }
/// </code>
/// </remarks>
public readonly partial struct TrainAspect : IAspect {
    // ...
}
```

## Aspect Patterns

### Property Accessors
```csharp
public readonly partial struct TransformAspect : IAspect {
    readonly RefRW<LocalTransform> transform;
    readonly RefRO<Velocity> velocity;
    
    // ? Expose clean property interface
    public float3 Position {
        get => transform.ValueRO.Position;
        set => transform.ValueRW.Position = value;
    }
    
    public float3 Velocity => velocity.ValueRO.Value;
    
    public quaternion Rotation {
        get => transform.ValueRO.Rotation;
        set => transform.ValueRW.Rotation = value;
    }
}
```

### Methods with Dependencies
```csharp
public readonly partial struct PathfindingAspect : IAspect {
    readonly RefRW<PathRequest> request;
    readonly RefRO<GridPosition> position;
    readonly RefRO<TargetPosition> target;
    
    /// <summary>
    /// Attempts to find a path from current position to target.
    /// </summary>
    /// <param name="gridData">Grid data for pathfinding</param>
    /// <param name="path">Output path buffer</param>
    /// <returns>True if path found, false otherwise</returns>
    public bool FindPath(ref GridData gridData, ref DynamicBuffer<PathNode> path) {
        // Use injected dependencies for complex operations
        return AStar.FindPath(
            position.ValueRO.Value,
            target.ValueRO.Value,
            ref gridData,
            ref path
        );
    }
}
```

### Validation Methods
```csharp
public readonly partial struct BuildingAspect : IAspect {
    readonly RefRO<GridPosition> position;
    readonly RefRO<BuildingSize> size;
    readonly RefRO<BuildingType> type;
    
    /// <summary>
    /// Checks if this building can be placed at its current position.
    /// </summary>
    public bool CanPlace(ComponentLookup<TerrainTile> terrainLookup) {
        var gridPos = position.ValueRO.Value;
        var buildingSize = size.ValueRO.Value;
        
        // Check all tiles under building footprint
        for (int x = 0; x < buildingSize.x; x++) {
            for (int y = 0; y < buildingSize.y; y++) {
                var tilePos = gridPos + new int2(x, y);
                if (!IsValidTile(tilePos, terrainLookup))
                    return false;
            }
        }
        
        return true;
    }
    
    private bool IsValidTile(int2 pos, ComponentLookup<TerrainTile> lookup) {
        // Validation logic...
        return true;
    }
}
```

## Usage in Systems

### Basic Iteration
```csharp
[BurstCompile]
public partial struct MovementSystem : ISystem {
    [BurstCompile]
    public void OnUpdate(ref SystemState state) {
        var deltaTime = SystemAPI.Time.DeltaTime;
        
        foreach (var vehicle in SystemAPI.Query<VehicleAspect>()) {
            vehicle.UpdateMovement(deltaTime);
        }
    }
}
```

### With Component Lookup
```csharp
[BurstCompile]
public partial struct TrainMovementSystem : ISystem {
    [BurstCompile]
    public void OnUpdate(ref SystemState state) {
        var deltaTime = SystemAPI.Time.DeltaTime;
        var trackLookup = SystemAPI.GetComponentLookup<TrackSegmentData>(true);
        
        foreach (var train in SystemAPI.Query<TrainAspect>()) {
            train.MoveAlongTrack(deltaTime, trackLookup);
        }
    }
}
```

### In Jobs
```csharp
[BurstCompile]
partial struct ProcessVehiclesJob : IJobEntity {
    public float DeltaTime;
    [ReadOnly] public ComponentLookup<TrackSegmentData> TrackLookup;
    
    void Execute(VehicleAspect vehicle) {
        vehicle.UpdateMovement(DeltaTime);
    }
}

[BurstCompile]
public partial struct VehicleSystem : ISystem {
    [BurstCompile]
    public void OnUpdate(ref SystemState state) {
        var job = new ProcessVehiclesJob {
            DeltaTime = SystemAPI.Time.DeltaTime,
            TrackLookup = SystemAPI.GetComponentLookup<TrackSegmentData>(true)
        };
        state.Dependency = job.ScheduleParallel(state.Dependency);
    }
}
```

## Best Practices

### 1. Keep Aspects Focused
```csharp
// ? Good: Single responsibility
public readonly partial struct MovementAspect : IAspect {
    // Only movement-related components and methods
}

public readonly partial struct RenderAspect : IAspect {
    // Only rendering-related components and methods
}

// ? Bad: Mixed responsibilities
public readonly partial struct EntityAspect : IAspect {
    // Movement, rendering, audio, UI, etc. - too broad
}
```

### 2. Use Aspects to Hide Complexity
```csharp
// ? Good: Complex logic hidden in aspect
public readonly partial struct StationAspect : IAspect {
    public bool CanAcceptTrain(TrainAspect train) {
        // Complex validation logic encapsulated
        return CheckCapacity() && CheckTrackCompatibility(train) && CheckPlatformAvailability();
    }
}

// System stays clean
foreach (var station in SystemAPI.Query<StationAspect>()) {
    if (station.CanAcceptTrain(incomingTrain)) {
        // Handle acceptance
    }
}
```

### 3. Prefer Readonly References
```csharp
// ? Good: Use RefRO for read-only access
public readonly partial struct AnalysisAspect : IAspect {
    readonly RefRO<Position> position;
    readonly RefRO<Velocity> velocity;
    readonly RefRO<Health> health;
    
    public float CalculateThreatLevel() {
        return velocity.ValueRO.Value.Length() * (1.0f - health.ValueRO.Value);
    }
}

// ? Bad: Use RefRW when only reading
public readonly partial struct AnalysisAspect : IAspect {
    readonly RefRW<Position> position; // ? Prevents parallel access
}
```

## Anti-Patterns

### ? State Storage in Aspects
```csharp
// ? Bad: Storing state
public partial struct BadAspect : IAspect {
    private float cachedValue; // ? No state storage
    private NativeList<Entity> nearby; // ? No collections
}

// ? Good: Stateless, pure behavior
public readonly partial struct GoodAspect : IAspect {
    readonly RefRW<LocalTransform> transform;
    
    public void Move(float3 delta) {
        transform.ValueRW.Position += delta;
    }
}
```

### ? Aspects Without Behavior
```csharp
// ? Bad: Just component grouping, no behavior
public readonly partial struct DataAspect : IAspect {
    public readonly RefRO<Position> Position;
    public readonly RefRO<Velocity> Velocity;
    // No methods - just use Query directly instead
}

// ? Good: Use query directly for simple data access
foreach (var (pos, vel) in SystemAPI.Query<RefRO<Position>, RefRO<Velocity>>()) {
    // Direct access when no complex logic needed
}
```

### ? Over-Abstraction
```csharp
// ? Bad: Aspect wrapping single component
public readonly partial struct PositionAspect : IAspect {
    readonly RefRW<Position> position;
    
    public float3 Value {
        get => position.ValueRO.Value;
        set => position.ValueRW.Value = value;
    }
}

// ? Good: Access component directly
foreach (var pos in SystemAPI.Query<RefRW<Position>>()) {
    pos.ValueRW.Value += delta;
}
```

## File Organization
- One aspect per file
- File name matches aspect name: `VehicleAspect.cs`
- Group related aspects in subdirectories:
  - `Aspects/Movement/`
  - `Aspects/Economy/`
  - `Aspects/World/`
