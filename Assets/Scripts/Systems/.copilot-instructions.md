# Systems - Copilot Instructions

## Purpose
This folder contains **ECS systems** that process entities and implement game logic. Systems are the "behavior" layer in ECS architecture.

## Rules

### 1. Systems Must Be Stateless
```csharp
// ? Good: Stateless system, dependencies via singletons
[BurstCompile]
public partial struct MovementSystem : ISystem {
    [BurstCompile]
    public void OnUpdate(ref SystemState state) {
        var deltaTime = SystemAPI.Time.DeltaTime;
        
        foreach (var (transform, velocity) in 
                 SystemAPI.Query<RefRW<LocalTransform>, RefRO<Velocity>>()) {
            transform.ValueRW.Position += velocity.ValueRO.Value * deltaTime;
        }
    }
}

// ? Bad: Stateful system with fields
public partial struct MovementSystem : ISystem {
    private float accumulatedTime;  // ? No mutable state
    private NativeList<Entity> entities; // ? No stored collections
}
```

**Exception**: Persistent `NativeContainer` fields are allowed if:
- Created in `OnCreate` with `Allocator.Persistent`
- Disposed in `OnDestroy`
- Used for caching/optimization only

```csharp
[BurstCompile]
public partial struct PathfindingSystem : ISystem {
    private NativeList<Entity> pathRequests;
    
    [BurstCompile]
    public void OnCreate(ref SystemState state) {
        pathRequests = new NativeList<Entity>(Allocator.Persistent);
    }
    
    [BurstCompile]
    public void OnDestroy(ref SystemState state) {
        if (pathRequests.IsCreated) pathRequests.Dispose();
    }
}
```

### 2. Use Burst for Performance-Critical Systems
```csharp
// ? Good: Burst-compiled system
[BurstCompile]
public partial struct VelocitySystem : ISystem {
    [BurstCompile]
    public void OnUpdate(ref SystemState state) {
        // Hot path code...
    }
}

// ?? Acceptable: Non-Burst for UI/managed code
public partial class UIUpdateSystem : SystemBase {
    protected override void OnUpdate() {
        // Managed UI code that can't be Burst-compiled
    }
}
```

### 3. Use Jobs for Parallel Processing
```csharp
// ? Good: Parallel job for large entity sets
[BurstCompile]
public partial struct GridUpdateSystem : ISystem {
    [BurstCompile]
    public void OnUpdate(ref SystemState state) {
        var job = new UpdateGridJob {
            DeltaTime = SystemAPI.Time.DeltaTime
        };
        state.Dependency = job.ScheduleParallel(state.Dependency);
    }
}

[BurstCompile]
partial struct UpdateGridJob : IJobEntity {
    public float DeltaTime;
    
    void Execute(ref GridPosition position, in Velocity velocity) {
        // Parallel execution per entity
    }
}
```

### 4. Use EntityCommandBuffer for Structural Changes
```csharp
// ? Good: Batch structural changes
[BurstCompile]
public partial struct SpawnSystem : ISystem {
    [BurstCompile]
    public void OnUpdate(ref SystemState state) {
        var ecb = SystemAPI.GetSingleton<BeginSimulationEntityCommandBufferSystem.Singleton>()
            .CreateCommandBuffer(state.WorldUnmanaged);
        
        foreach (var spawner in SystemAPI.Query<RefRO<Spawner>>()) {
            var entity = ecb.CreateEntity();
            ecb.AddComponent(entity, new Position { Value = spawner.ValueRO.SpawnPoint });
        }
    }
}

// ? Bad: Immediate structural changes in loop
public partial struct SpawnSystem : ISystem {
    public void OnUpdate(ref SystemState state) {
        foreach (var spawner in SystemAPI.Query<RefRO<Spawner>>()) {
            var entity = state.EntityManager.CreateEntity(); // ? Invalidates queries
            // ...
        }
    }
}
```

### 5. System Update Groups & Ordering
```csharp
// ? Good: Explicit ordering
[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]
[UpdateBefore(typeof(MovementSystem))]
public partial struct AccelerationSystem : ISystem {
    // Runs in fixed timestep, before movement
}

[UpdateInGroup(typeof(SimulationSystemGroup))]
[UpdateAfter(typeof(MovementSystem))]
public partial struct CollisionSystem : ISystem {
    // Runs after movement in variable timestep
}
```

**Common Update Groups:**
- `InitializationSystemGroup`: Setup, initialization
- `FixedStepSimulationSystemGroup`: Deterministic simulation (physics, gameplay)
- `SimulationSystemGroup`: Variable timestep simulation
- `PresentationSystemGroup`: Rendering, interpolation, UI

### 6. Naming Conventions
- **Pattern**: `<Verb><Noun>System`
- **Examples**: `MovementSystem`, `CollisionDetectionSystem`, `PathfindingSystem`
- **Avoid**: Generic names like `UpdateSystem`, `ProcessorSystem`

### 7. Documentation
Every system must have XML documentation explaining:
- **Purpose**: What does this system do?
- **Dependencies**: What components/singletons does it require?
- **Update order**: When does it run relative to other systems?
- **Performance**: Expected entity count, profiling notes

```csharp
/// <summary>
/// Updates entity positions based on velocity.
/// Runs in FixedStepSimulationSystemGroup for deterministic physics.
/// </summary>
/// <remarks>
/// Expected load: 10k-50k entities
/// Performance target: <1ms per frame
/// </remarks>
[BurstCompile]
[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]
public partial struct MovementSystem : ISystem {
    // ...
}
```

## System Patterns

### Query Patterns

#### Simple Foreach Query
```csharp
foreach (var (transform, velocity) in 
         SystemAPI.Query<RefRW<LocalTransform>, RefRO<Velocity>>()) {
    transform.ValueRW.Position += velocity.ValueRO.Value * deltaTime;
}
```

#### Query with Entity Access
```csharp
foreach (var (entity, velocity) in 
         SystemAPI.Query<RefRO<Velocity>>().WithEntityAccess()) {
    if (velocity.ValueRO.Value.LengthSq() > 100f) {
        SystemAPI.SetComponentEnabled<IsFast>(entity, true);
    }
}
```

#### Query with Filters
```csharp
foreach (var transform in 
         SystemAPI.Query<RefRW<LocalTransform>>()
                   .WithAll<IsMoving>()
                   .WithNone<IsPaused>()) {
    // Only entities with IsMoving and without IsPaused
}
```

### Singleton Patterns

#### Read Singleton
```csharp
var config = SystemAPI.GetSingleton<GameConfig>();
var gravity = config.Gravity;
```

#### Write Singleton
```csharp
var config = SystemAPI.GetSingletonRW<GameConfig>();
config.ValueRW.TimeScale = 2.0f;
```

### Aspect Patterns
```csharp
// Define aspect (in Aspects folder)
public readonly partial struct TransformAspect : IAspect {
    readonly RefRW<LocalTransform> transform;
    readonly RefRO<Velocity> velocity;
    
    public void Move(float deltaTime) {
        transform.ValueRW.Position += velocity.ValueRO.Value * deltaTime;
    }
}

// Use in system
foreach (var aspect in SystemAPI.Query<TransformAspect>()) {
    aspect.Move(deltaTime);
}
```

## Performance Best Practices

### 1. Minimize Component Access
```csharp
// ? Good: Read once, cache locally
var deltaTime = SystemAPI.Time.DeltaTime;
var gravity = SystemAPI.GetSingleton<PhysicsConfig>().Gravity;

foreach (var velocity in SystemAPI.Query<RefRW<Velocity>>()) {
    velocity.ValueRW.Value += gravity * deltaTime;
}

// ? Bad: Repeated singleton access
foreach (var velocity in SystemAPI.Query<RefRW<Velocity>>()) {
    velocity.ValueRW.Value += SystemAPI.GetSingleton<PhysicsConfig>().Gravity 
                             * SystemAPI.Time.DeltaTime;  // ? Repeated calls
}
```

### 2. Use Parallel Jobs for Large Data Sets
```csharp
// ? Good: Parallel job for 1000+ entities
[BurstCompile]
partial struct UpdateJob : IJobEntity {
    void Execute(ref Position pos, in Velocity vel) { /* ... */ }
}

// ? Bad: Foreach for large data sets (use only for <1000 entities)
foreach (var (pos, vel) in SystemAPI.Query<RefRW<Position>, RefRO<Velocity>>()) {
    // Non-parallel processing
}
```

### 3. Batch EntityCommandBuffer Operations
```csharp
// ? Good: Single ECB for all changes
var ecb = SystemAPI.GetSingleton<BeginSimulationEntityCommandBufferSystem.Singleton>()
    .CreateCommandBuffer(state.WorldUnmanaged);

foreach (var (entity, health) in 
         SystemAPI.Query<RefRO<Health>>().WithEntityAccess()) {
    if (health.ValueRO.Value <= 0) {
        ecb.DestroyEntity(entity);
    }
}

// ? Bad: Multiple ECB instances
foreach (var entity in query) {
    var ecb = new EntityCommandBuffer(Allocator.TempJob); // ? Per-entity allocation
    ecb.DestroyEntity(entity);
    ecb.Playback(state.EntityManager);
    ecb.Dispose();
}
```

## Anti-Patterns

### ? Direct EntityManager Access in Jobs
```csharp
// ? Bad: Can't access EntityManager in job
[BurstCompile]
partial struct BadJob : IJobEntity {
    public EntityManager Manager; // ? Not Burst-compatible
    
    void Execute(Entity entity) {
        Manager.DestroyEntity(entity); // ? Unsafe
    }
}

// ? Good: Use EntityCommandBuffer.ParallelWriter
[BurstCompile]
partial struct GoodJob : IJobEntity {
    public EntityCommandBuffer.ParallelWriter Ecb;
    
    void Execute(Entity entity, [ChunkIndexInQuery] int sortKey) {
        Ecb.DestroyEntity(sortKey, entity);
    }
}
```

### ? LINQ in Systems
```csharp
// ? Bad: LINQ allocates garbage
var entities = query.ToEntityArray(Allocator.Temp)
    .Where(e => HasComponent<Health>(e))
    .ToList(); // ? GC allocation

// ? Good: Explicit loop with native container
var entities = new NativeList<Entity>(Allocator.Temp);
foreach (var (entity, health) in 
         SystemAPI.Query<RefRO<Health>>().WithEntityAccess()) {
    entities.Add(entity);
}
```

### ? Nested Queries
```csharp
// ? Bad: Nested iteration (O(n²) complexity)
foreach (var entityA in SystemAPI.Query<RefRO<Position>>()) {
    foreach (var entityB in SystemAPI.Query<RefRO<Position>>()) {
        // ? Very slow for large entity counts
    }
}

// ? Good: Use spatial partitioning or collect to array first
var positions = query.ToComponentDataArray<Position>(Allocator.Temp);
// Process with efficient algorithm
```

## File Organization
- One system per file
- File name matches system name: `MovementSystem.cs`
- Group related systems in subdirectories:
  - `Systems/Movement/`
  - `Systems/Economy/`
  - `Systems/World/`
