# Components - Copilot Instructions

## Purpose
This folder contains **pure data components** for ECS entities. Components are unmanaged structs that define the data schema for simulation.

## Rules

### 1. Components Must Be Pure Data
```csharp
// ? Good: Pure data, unmanaged
public struct GridPosition : IComponentData {
    public int2 Value;
}

// ? Bad: Managed field
public struct GridPosition : IComponentData {
    public string LocationName;  // ? No managed types
}
```

### 2. Keep Components Small & Focused
```csharp
// ? Good: Single responsibility
public struct Health : IComponentData { public float Value; }
public struct MaxHealth : IComponentData { public float Value; }

// ? Bad: Too many responsibilities
public struct EntityStats : IComponentData {
    public float Health;
    public float MaxHealth;
    public float Speed;
    public float AttackPower;
    // ... (10+ fields)
}
```

### 3. Use Enableable Components for Toggleable States
```csharp
// ? Good: No-data state marker
public struct IsSelected : IComponentData, IEnableableComponent { }
public struct IsPaused : IComponentData, IEnableableComponent { }

// ? Bad: Boolean field for state
public struct SelectionState : IComponentData {
    public bool IsSelected;  // ? Wasteful, use enableable component
}
```

### 4. Use DynamicBuffer for Variable-Length Data
```csharp
// ? Good: Buffer for dynamic-length collections
public struct PathNode : IBufferElementData {
    public float3 Position;
}

// Usage in system:
// var path = state.EntityManager.GetBuffer<PathNode>(entity);

// ? Bad: Fixed array or managed collection
public struct Path : IComponentData {
    public NativeArray<float3> Nodes;  // ? Can't store in component
}
```

### 5. Naming Conventions
- **Noun-based names**: `Velocity`, `GridPosition`, `TrackSegment`
- **State markers**: Prefix with `Is` or `Has` (e.g., `IsMoving`, `HasCargo`)
- **Buffer elements**: Suffix with `Element` (e.g., `PathNodeElement`, `CarriageElement`)

### 6. Prefer Specific Types Over Generic
```csharp
// ? Good: Explicit, self-documenting
public struct Speed : IComponentData { public float Value; }
public struct MaxSpeed : IComponentData { public float Value; }

// ? Bad: Generic, unclear purpose
public struct FloatValue1 : IComponentData { public float Value; }
public struct FloatValue2 : IComponentData { public float Value; }
```

### 7. Documentation
Every component must have XML documentation explaining:
- **Purpose**: What does this component represent?
- **Usage**: Which entities should have this component?
- **Units**: For numeric values (e.g., meters, meters/second, degrees)

```csharp
/// <summary>
/// Represents the current velocity of an entity in world space.
/// Units: meters per second
/// </summary>
public struct Velocity : IComponentData {
    /// <summary>Direction and magnitude of velocity in meters/second</summary>
    public float3 Value;
}
```

## Component Categories

### Spatial Components
- Position, rotation, scale
- Grid coordinates
- Bounds, extents

### Movement Components
- Velocity, acceleration
- Speed limits
- Movement state (grounded, airborne, etc.)

### State Components (Enableable)
- Selection state
- Pause state
- Active/inactive state

### Reference Components
- Entity references (parent, target, etc.)
- Blob asset references
- Singleton references

### Configuration Components
- Read-only parameters
- Entity-specific settings

## Anti-Patterns

### ? Managed Types in Components
```csharp
// ? Bad
public struct BuildingData : IComponentData {
    public string Name;           // ? Managed string
    public List<Entity> Workers;  // ? Managed list
}

// ? Good
public struct BuildingData : IComponentData {
    public FixedString64Bytes Name;  // ? Unmanaged string
    // Workers stored in DynamicBuffer<WorkerElement>
}
```

### ? Duplicate Data
```csharp
// ? Bad: Redundant data that can be calculated
public struct Movement : IComponentData {
    public float3 Velocity;
    public float Speed;  // ? Redundant: Speed = length(Velocity)
}

// ? Good: Store minimal data
public struct Velocity : IComponentData {
    public float3 Value;
}
// Calculate speed in systems when needed
```

### ? Behavior in Components
```csharp
// ? Bad: Methods in component
public struct Health : IComponentData {
    public float Value;
    
    public void TakeDamage(float amount) { // ? No methods
        Value -= amount;
    }
}

// ? Good: Pure data, behavior in systems
public struct Health : IComponentData {
    public float Value;
}
```

## File Organization
- One component per file
- File name matches component name: `Velocity.cs`, `GridPosition.cs`
- Group related components in subdirectories if needed:
  - `Components/Movement/`
  - `Components/Economy/`
  - `Components/World/`
