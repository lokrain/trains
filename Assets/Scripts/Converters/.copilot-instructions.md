# Converters (Authoring) - Copilot Instructions

## Purpose
This folder contains **authoring components** (MonoBehaviours) and **bakers** that convert GameObject-based authoring data into ECS components at bake time.

## Rules

### 1. Authoring Components Are MonoBehaviours
```csharp
// ? Good: Simple authoring component with serializable fields
public class VehicleAuthoring : MonoBehaviour {
    [Header("Movement")]
    public float maxSpeed = 50f;
    public float acceleration = 10f;
    
    [Header("Visual")]
    public Mesh mesh;
    public Material material;
}
```

### 2. Bakers Convert Authoring to ECS Components
```csharp
// ? Good: Baker converts authoring data to ECS components
public class VehicleBaker : Baker<VehicleAuthoring> {
    public override void Bake(VehicleAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        
        // Add runtime components
        AddComponent(entity, new Speed { Value = authoring.maxSpeed });
        AddComponent(entity, new Acceleration { Value = authoring.acceleration });
        
        // Add rendering components
        AddComponent(entity, new RenderMesh {
            mesh = authoring.mesh,
            material = authoring.material
        });
    }
}
```

### 3. Keep Authoring Components Simple
```csharp
// ? Good: Authoring component is just data container
public class TrackAuthoring : MonoBehaviour {
    public Transform startPoint;
    public Transform endPoint;
    public TrackType trackType;
    public float width = 2.0f;
}

// ? Bad: Logic in authoring component
public class TrackAuthoring : MonoBehaviour {
    public Transform startPoint;
    public Transform endPoint;
    
    void Update() { // ? No runtime behavior in authoring components
        DrawDebugLine();
    }
    
    private void DrawDebugLine() { /* ... */ }
}
```

### 4. Use GetEntity with Correct TransformUsageFlags
```csharp
// ? Good: Specify correct transform usage
public class VehicleBaker : Baker<VehicleAuthoring> {
    public override void Bake(VehicleAuthoring authoring) {
        // Dynamic entity (moves at runtime)
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        
        // Add components...
    }
}

public class StaticBuildingBaker : Baker<BuildingAuthoring> {
    public override void Bake(BuildingAuthoring authoring) {
        // Static entity (doesn't move)
        var entity = GetEntity(TransformUsageFlags.Renderable);
        
        // Add components...
    }
}
```

**TransformUsageFlags options:**
- `Dynamic`: Entity moves at runtime (has LocalTransform, LocalToWorld)
- `Renderable`: Static entity that renders (only LocalToWorld)
- `WorldSpace`: Static entity without rendering
- `None`: No transform components

### 5. Declare Dependencies Explicitly
```csharp
// ? Good: Declare dependencies on authoring data
public class TrackBaker : Baker<TrackAuthoring> {
    public override void Bake(TrackAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        
        // Declare dependency on transform changes
        DependsOn(authoring.startPoint);
        DependsOn(authoring.endPoint);
        
        var startPos = authoring.startPoint.position;
        var endPos = authoring.endPoint.position;
        
        AddComponent(entity, new TrackSegment {
            StartPosition = startPos,
            EndPosition = endPos,
            Length = math.distance(startPos, endPos)
        });
    }
}
```

### 6. Create Additional Entities in Bakers
```csharp
// ? Good: Create multiple entities from single authoring component
public class StationBaker : Baker<StationAuthoring> {
    public override void Bake(StationAuthoring authoring) {
        // Main station entity
        var stationEntity = GetEntity(TransformUsageFlags.Renderable);
        AddComponent(stationEntity, new Station {
            Name = authoring.stationName,
            Capacity = authoring.platformCount
        });
        
        // Create platform entities
        var platforms = AddBuffer<PlatformReference>(stationEntity);
        for (int i = 0; i < authoring.platformCount; i++) {
            var platformEntity = CreateAdditionalEntity(TransformUsageFlags.Dynamic);
            AddComponent(platformEntity, new Platform {
                StationEntity = stationEntity,
                Index = i
            });
            AddComponent(platformEntity, new LocalTransform {
                Position = authoring.transform.position + new Vector3(i * 5f, 0, 0),
                Rotation = quaternion.identity,
                Scale = 1f
            });
            
            platforms.Add(new PlatformReference { Value = platformEntity });
        }
    }
}
```

### 7. Use BlobAssets for Read-Only Data
```csharp
// ? Good: Bake read-only data into blob assets
public class VehicleDefinitionBaker : Baker<VehicleDefinitionAuthoring> {
    public override void Bake(VehicleDefinitionAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.None);
        
        // Create blob asset
        using var builder = new BlobBuilder(Allocator.Temp);
        ref var definition = ref builder.ConstructRoot<VehicleDefinition>();
        
        // Build vertex array
        var mesh = authoring.mesh;
        var vertices = builder.Allocate(ref definition.Vertices, mesh.vertexCount);
        for (int i = 0; i < mesh.vertexCount; i++) {
            vertices[i] = mesh.vertices[i];
        }
        
        // Set properties
        definition.MaxSpeed = authoring.maxSpeed;
        definition.Acceleration = authoring.acceleration;
        
        // Create and add blob reference
        var blobRef = builder.CreateBlobAssetReference<VehicleDefinition>(Allocator.Persistent);
        AddBlobAsset(ref blobRef, out var hash);
        
        AddComponent(entity, new VehicleDefinitionRef { Value = blobRef });
    }
}
```

### 8. Naming Conventions
- **Authoring components**: Suffix with `Authoring` (e.g., `VehicleAuthoring`, `TrackAuthoring`)
- **Bakers**: Suffix with `Baker` (e.g., `VehicleBaker`, `TrackBaker`)
- **File names**: Match class names

### 9. Documentation
Every authoring component and baker must have XML documentation explaining:
- **Purpose**: What does this authoring component configure?
- **Runtime behavior**: What ECS components does it create?
- **Editor usage**: How should designers use this in the editor?

```csharp
/// <summary>
/// Authoring component for configuring vehicle properties.
/// Creates a runtime entity with Speed, Acceleration, and rendering components.
/// </summary>
/// <remarks>
/// Place this on a GameObject to create a vehicle entity at bake time.
/// The GameObject's transform will be used for the initial position.
/// </remarks>
public class VehicleAuthoring : MonoBehaviour {
    [Header("Movement")]
    [Tooltip("Maximum speed in meters per second")]
    public float maxSpeed = 50f;
    
    [Tooltip("Acceleration in meters per second squared")]
    public float acceleration = 10f;
}

/// <summary>
/// Bakes VehicleAuthoring data into ECS components.
/// </summary>
public class VehicleBaker : Baker<VehicleAuthoring> {
    public override void Bake(VehicleAuthoring authoring) {
        // Implementation...
    }
}
```

## Baker Patterns

### Basic Component Conversion
```csharp
public class SimpleBaker : Baker<SimpleAuthoring> {
    public override void Bake(SimpleAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        
        // Convert authoring fields to components
        AddComponent(entity, new Health { Value = authoring.maxHealth });
        AddComponent(entity, new Speed { Value = authoring.speed });
    }
}
```

### With Buffer Conversion
```csharp
public class PathAuthoring : MonoBehaviour {
    public Transform[] waypoints;
}

public class PathBaker : Baker<PathAuthoring> {
    public override void Bake(PathAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        
        // Convert array to DynamicBuffer
        var waypoints = AddBuffer<Waypoint>(entity);
        foreach (var transform in authoring.waypoints) {
            DependsOn(transform);
            waypoints.Add(new Waypoint { Position = transform.position });
        }
    }
}
```

### With Asset Dependencies
```csharp
public class SpawnerBaker : Baker<SpawnerAuthoring> {
    public override void Bake(SpawnerAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        
        // Declare dependency on prefab asset
        var prefabEntity = GetEntity(authoring.prefabToSpawn, TransformUsageFlags.Dynamic);
        
        AddComponent(entity, new Spawner {
            Prefab = prefabEntity,
            SpawnRate = authoring.spawnRate,
            MaxCount = authoring.maxCount
        });
    }
}
```

### With Child Hierarchy
```csharp
public class BuildingBaker : Baker<BuildingAuthoring> {
    public override void Bake(BuildingAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Renderable);
        
        // Process child transforms
        var children = AddBuffer<LinkedEntityGroup>(entity);
        foreach (Transform child in authoring.transform) {
            var childEntity = GetEntity(child, TransformUsageFlags.Dynamic);
            children.Add(new LinkedEntityGroup { Value = childEntity });
            
            // Add components to children
            AddComponent(childEntity, new ChildComponent {
                Parent = entity,
                LocalOffset = child.localPosition
            });
        }
    }
}
```

## Editor Integration

### Custom Inspector (Optional)
```csharp
#if UNITY_EDITOR
using UnityEditor;

[CustomEditor(typeof(VehicleAuthoring))]
public class VehicleAuthoringEditor : Editor {
    public override void OnInspectorGUI() {
        DrawDefaultInspector();
        
        var authoring = (VehicleAuthoring)target;
        
        EditorGUILayout.Space();
        EditorGUILayout.HelpBox(
            $"Max Speed: {authoring.maxSpeed} m/s\n" +
            $"Acceleration: {authoring.acceleration} m/s²",
            MessageType.Info
        );
    }
}
#endif
```

### Gizmos for Visualization
```csharp
public class TrackAuthoring : MonoBehaviour {
    public Transform startPoint;
    public Transform endPoint;
    public float width = 2.0f;
    
#if UNITY_EDITOR
    private void OnDrawGizmos() {
        if (startPoint == null || endPoint == null) return;
        
        Gizmos.color = Color.yellow;
        Gizmos.DrawLine(startPoint.position, endPoint.position);
        
        // Draw width indicators
        var direction = (endPoint.position - startPoint.position).normalized;
        var perpendicular = Vector3.Cross(direction, Vector3.up).normalized * (width * 0.5f);
        
        Gizmos.color = Color.cyan;
        Gizmos.DrawLine(
            startPoint.position + perpendicular,
            endPoint.position + perpendicular
        );
        Gizmos.DrawLine(
            startPoint.position - perpendicular,
            endPoint.position - perpendicular
        );
    }
#endif
}
```

## Best Practices

### 1. Keep Bakers Simple
```csharp
// ? Good: Simple, focused baker
public class HealthBaker : Baker<HealthAuthoring> {
    public override void Bake(HealthAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        AddComponent(entity, new Health { Value = authoring.maxHealth });
        AddComponent(entity, new MaxHealth { Value = authoring.maxHealth });
    }
}

// ? Bad: Complex logic in baker
public class HealthBaker : Baker<HealthAuthoring> {
    public override void Bake(HealthAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        
        // ? Too much logic - move to utility or system
        var healthValue = CalculateHealthBasedOnDifficulty(authoring);
        var regenRate = CalculateRegenRate(authoring);
        var immunities = CalculateImmunities(authoring);
        // ... 50 more lines
    }
}
```

### 2. Use Tooltips and Headers
```csharp
public class VehicleAuthoring : MonoBehaviour {
    [Header("Movement Settings")]
    [Tooltip("Maximum speed in meters per second")]
    [Range(0f, 200f)]
    public float maxSpeed = 50f;
    
    [Tooltip("Time to reach max speed in seconds")]
    [Range(0.1f, 10f)]
    public float accelerationTime = 2f;
    
    [Header("Visual Settings")]
    [Tooltip("3D mesh for this vehicle")]
    public Mesh mesh;
    
    [Tooltip("Material to apply to the mesh")]
    public Material material;
}
```

### 3. Validate Input
```csharp
public class TrackBaker : Baker<TrackAuthoring> {
    public override void Bake(TrackAuthoring authoring) {
        // Validate authoring data
        if (authoring.startPoint == null || authoring.endPoint == null) {
            Debug.LogError($"TrackAuthoring on {authoring.name} is missing start/end points!", authoring);
            return;
        }
        
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        
        // Continue with baking...
    }
}
```

### 4. Separate Authoring from Runtime
```csharp
// ? Good: Authoring data separate from runtime components
public class VehicleAuthoring : MonoBehaviour {
    public float maxSpeed = 50f;
    public float accelerationTime = 2f;
}

public class VehicleBaker : Baker<VehicleAuthoring> {
    public override void Bake(VehicleAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        
        // Calculate runtime values
        var acceleration = authoring.maxSpeed / authoring.accelerationTime;
        
        AddComponent(entity, new Speed { Value = 0f }); // Current speed starts at 0
        AddComponent(entity, new MaxSpeed { Value = authoring.maxSpeed });
        AddComponent(entity, new Acceleration { Value = acceleration });
    }
}
```

## Anti-Patterns

### ? Runtime Behavior in Authoring
```csharp
// ? Bad: Update logic in authoring component
public class VehicleAuthoring : MonoBehaviour {
    public float speed = 10f;
    
    void Update() { // ? No runtime behavior
        transform.position += transform.forward * speed * Time.deltaTime;
    }
}

// ? Good: Pure data authoring
public class VehicleAuthoring : MonoBehaviour {
    public float maxSpeed = 50f;
    // No Update, no runtime logic
}
```

### ? Direct EntityManager Access
```csharp
// ? Bad: Accessing EntityManager directly
public class BadBaker : Baker<BadAuthoring> {
    public override void Bake(BadAuthoring authoring) {
        var entityManager = World.DefaultGameObjectInjectionWorld.EntityManager; // ? Don't do this
        var entity = entityManager.CreateEntity(); // ? Use GetEntity instead
    }
}

// ? Good: Use Baker API
public class GoodBaker : Baker<GoodAuthoring> {
    public override void Bake(GoodAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        AddComponent(entity, new MyComponent());
    }
}
```

### ? Caching State in Baker
```csharp
// ? Bad: Storing state in baker
public class BadBaker : Baker<BadAuthoring> {
    private NativeList<Entity> createdEntities; // ? No state in bakers
    
    public override void Bake(BadAuthoring authoring) {
        // ...
    }
}

// ? Good: Stateless baker
public class GoodBaker : Baker<GoodAuthoring> {
    public override void Bake(GoodAuthoring authoring) {
        // All state is local to Bake method
        var entity = GetEntity(TransformUsageFlags.Dynamic);
    }
}
```

## Common Use Cases

### Prefab Conversion
```csharp
public class PrefabBaker : Baker<PrefabAuthoring> {
    public override void Bake(PrefabAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        
        // Mark as prefab (won't be instantiated automatically)
        AddComponent(entity, new Prefab());
    }
}
```

### Singleton Conversion
```csharp
public class GameConfigAuthoring : MonoBehaviour {
    public float gravity = 9.81f;
    public float timeScale = 1.0f;
}

public class GameConfigBaker : Baker<GameConfigAuthoring> {
    public override void Bake(GameConfigAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.None);
        
        // Create singleton component
        AddComponent(entity, new GameConfig {
            Gravity = authoring.gravity,
            TimeScale = authoring.timeScale
        });
    }
}
```

## File Organization
- One authoring component per file
- One baker per file (or combine with authoring in same file)
- File names match class names: `VehicleAuthoring.cs`, `VehicleBaker.cs`
- Group related authoring components in subdirectories:
  - `Converters/Vehicles/`
  - `Converters/Buildings/`
  - `Converters/Terrain/`
